import * as cdk from "aws-cdk-lib"
import {aws_ec2, Fn, RemovalPolicy} from "aws-cdk-lib"
import {Application} from "aws-cdk-lib/aws-appconfig"
import * as applicationautoscaling from "aws-cdk-lib/aws-applicationautoscaling"
import {TcpRetryEvent} from "aws-cdk-lib/aws-appmesh"
import * as certificatemanager from "aws-cdk-lib/aws-certificatemanager"
import {Certificate, CertificateValidation} from "aws-cdk-lib/aws-certificatemanager"
import * as ec2 from "aws-cdk-lib/aws-ec2"
import {Port, Vpc} from "aws-cdk-lib/aws-ec2"
import * as ecs from "aws-cdk-lib/aws-ecs"
import {ApplicationLoadBalancedFargateService} from "aws-cdk-lib/aws-ecs-patterns"
import * as elasticloadbalancingv2 from "aws-cdk-lib/aws-elasticloadbalancingv2"
import {ApplicationTargetGroup, IpAddressType, TrustStore} from "aws-cdk-lib/aws-elasticloadbalancingv2"
import * as iam from "aws-cdk-lib/aws-iam"
import {ManagedPolicy, Role} from "aws-cdk-lib/aws-iam"
import {Stream} from "aws-cdk-lib/aws-kinesis"
import {Key} from "aws-cdk-lib/aws-kms"
import * as logs from "aws-cdk-lib/aws-logs"
import {
  CfnLogGroup,
  FilterPattern,
  LogGroup,
  SubscriptionFilter
} from "aws-cdk-lib/aws-logs"
import {KinesisDestination} from "aws-cdk-lib/aws-logs-destinations"
import * as route53 from "aws-cdk-lib/aws-route53"
import {HostedZone} from "aws-cdk-lib/aws-route53"
import {Bucket} from "aws-cdk-lib/aws-s3"

export interface PrescribeDispenseStackProps extends cdk.StackProps {
  /**
   */
  readonly stackName: string;
  /**
   */
  readonly enableMutualTls: string;
  /**
   */
  readonly truststoreBucketName: string;
  /**
   */
  readonly truststoreVersion: string;
  /**
   */
  readonly truststoreFile: string;
  /**
   */
  readonly versionNumber: string;
  /**
   */
  readonly commitId: string;
  /**
   * @default 9000
   */
  readonly containerPort: number;
  /**
   * @default 9001
   */
  readonly containerPortValidator?: string;
  /**
   * @default 'dev'
   */
  readonly environment?: string;
  /**
   */
  readonly logRetentionInDays: number;
  /**
   */
  readonly logLevel: string;
  /**
   * @default 'INFO'
   */
  readonly validatorLogLevel?: string;
  /**
   */
  readonly targetSpineServer: string;
  /**
   */
  readonly dockerImageTag: string;
  /**
   */
  readonly toAsid: string;
  /**
   */
  readonly toPartyKey: string;
}

/**
 * Main template for Load Balancer with all resources included, supporting mutual TLS and ECS Fargate deployment

 */
export class PrescribeDispenseStack extends cdk.Stack {
  /**
   * Load Balancer Endpoint
   */
  public readonly endpoint
  /**
   * ARN of the Load Balancer
   */
  public readonly loadBalancerArn
  /**
   * ARN of the Target Group
   */
  public readonly targetGroupArn
  /**
   * Security Group IDs associated with the Load Balancer
   */
  public readonly securityGroupIds
  /**
   * Name of the ECS Cluster
   */
  public readonly ecsClusterName
  /**
   * Name of the ECS Service
   */
  public readonly ecsServiceName
  /**
   * ARN of the ECS Task Definition
   */
  public readonly ecsTaskDefinitionArn

  public constructor(scope: cdk.App, id: string, props: PrescribeDispenseStackProps) {
    super(scope, id, props)

    // Applying default props
    props = {
      ...props,
      containerPort: props.containerPort ?? 9000,
      containerPortValidator: props.containerPortValidator ?? 9001,
      environment: props.environment ?? "dev",
      validatorLogLevel: props.validatorLogLevel ?? "INFO"
    }

    const epsDomainName: string = this.node.tryGetContext("epsDomainName")
    const epsHostedZoneId: string = this.node.tryGetContext("epsHostedZoneId")

    const hostedZone = HostedZone.fromHostedZoneAttributes(this, "hostedZone", {
      hostedZoneId: epsHostedZoneId,
      zoneName: epsDomainName
    })

    // Conditions
    const createTruststore = props.enableMutualTls! === "true"
    const isRefOrProd = (props.environment! === "ref" || props.environment! === "prod")

    // Resources

    const cloudWatchLogsKmsKey = Key.fromKeyArn(
      this, "cloudWatchLogsKmsKey", Fn.importValue("account-resources:CloudwatchLogsKmsKeyArn"))

    const defaultVpc = Vpc.fromLookup(
      this, "defaultVpc", {
        vpcId: Fn.importValue("vpc-resources:VpcId")
      })

    const splunkDeliveryStream = Stream.fromStreamArn(
      this, "SplunkDeliveryStream", Fn.importValue("lambda-resources:SplunkDeliveryStream"))

    const splunkSubscriptionFilterRole = Role.fromRoleArn(
      this, "splunkSubscriptionFilterRole", Fn.importValue("lambda-resources:SplunkSubscriptionFilterRole"))

    const coordinatorLogGroup = new LogGroup(this, "CoordinatorLogGroup", {
      encryptionKey: cloudWatchLogsKmsKey,
      logGroupName: `/aws/ecs/${props.stackName!}-coordinator`,
      retention: props.logRetentionInDays,
      removalPolicy: RemovalPolicy.DESTROY
    })

    const cfnCoordinatorLogGroup = coordinatorLogGroup.node.defaultChild as CfnLogGroup
    cfnCoordinatorLogGroup.cfnOptions.metadata = {
      guard: {
        SuppressedRules: [
          "CW_LOGGROUP_RETENTION_PERIOD_CHECK"
        ]
      }
    }

    new SubscriptionFilter(this, "CoordinatorSplunkSubscriptionFilter", {
      logGroup: coordinatorLogGroup,
      filterPattern: FilterPattern.allTerms(),
      destination: new KinesisDestination(splunkDeliveryStream, {
        role: splunkSubscriptionFilterRole
      })
    })
    const validatorLogGroup = new LogGroup(this, "ValidatorLogGroup", {
      encryptionKey: cloudWatchLogsKmsKey,
      logGroupName: `/aws/ecs/${props.stackName!}-validator`,
      retention: props.logRetentionInDays,
      removalPolicy: RemovalPolicy.DESTROY
    })

    const cfnValidatorLogGroup = validatorLogGroup.node.defaultChild as CfnLogGroup
    cfnValidatorLogGroup.cfnOptions.metadata = {
      guard: {
        SuppressedRules: [
          "CW_LOGGROUP_RETENTION_PERIOD_CHECK"
        ]
      }
    }

    new SubscriptionFilter(this, "ValidatorSplunkSubscriptionFilter", {
      logGroup: validatorLogGroup,
      filterPattern: FilterPattern.allTerms(),
      destination: new KinesisDestination(splunkDeliveryStream, {
        role: splunkSubscriptionFilterRole
      })
    })
    const ecsCluster = new ecs.Cluster(this, "EcsCluster", {vpc: defaultVpc})

    const ecsAutoScaleRolePolicy = ManagedPolicy.fromManagedPolicyArn(
      this,
      "EcsAutoScaleRolePolicy",
      "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole"
    )
    const ecsServiceAutoScalingRole = new Role(this, "ECSServiceAutoScalingRole", {
      assumedBy: new iam.ServicePrincipal("application-autoscaling.amazonaws.com"),
      managedPolicies: [
        ecsAutoScaleRolePolicy
      ],
      roleName: `${props.stackName!}-ecsAutoScalingRole`
    })

    const ecsTaskExecutionRolePolicy = ManagedPolicy.fromManagedPolicyArn(
      this,
      "AmazonECSTaskExecutionRolePolicy",
      "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
    )
    const lambdaAccessSecretsPolicy = ManagedPolicy.fromManagedPolicyArn(
      this,
      "LambdaAccessSecretsPolicy",
      Fn.importValue("account-resources:LambdaAccessSecretsPolicy")
    )
    const lambdaDecryptSecretsKMSPolicy = ManagedPolicy.fromManagedPolicyArn(
      this,
      "LambdaDecryptSecretsKMSPolicy",
      Fn.importValue("account-resources:LambdaDecryptSecretsKMSPolicy")
    )
    const epsSigningCertChainManagedPolicy = ManagedPolicy.fromManagedPolicyArn(
      this,
      "EpsSigningCertChainManagedPolicy",
      Fn.importValue("secrets:epsSigningCertChainManagedPolicy")
    )

    const ecsTaskExecutionRole = new Role(this, "EcsTaskExecutionRole", {
      assumedBy: new iam.ServicePrincipal("ecs-tasks.amazonaws.com"),
      managedPolicies: [
        ecsTaskExecutionRolePolicy,
        lambdaAccessSecretsPolicy,
        lambdaDecryptSecretsKMSPolicy,
        epsSigningCertChainManagedPolicy
      ],
      roleName: `${props.stackName!}-ecsTaskExecutionRole`
    })

    const albCertificate = new Certificate(this, "AlbCertificate", {
      domainName: `${props.stackName}.${epsDomainName}`,
      validation: CertificateValidation.fromDns(hostedZone)
    })

    const loadBalancerSecurityGroup = new ec2.SecurityGroup(this, "LoadBalancerSecurityGroup", {
      vpc: defaultVpc,
      description: "Allow inbound HTTPS traffic",
      allowAllOutbound: true,
      securityGroupName: `${props.stackName!}-lb-sg`
    })

    loadBalancerSecurityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), "ipv4 https frm anywhere")
    loadBalancerSecurityGroup.addIngressRule(ec2.Peer.anyIpv6(), ec2.Port.tcp(443), "ipv6 https frm anywhere")

    const containerSecurityGroup = new ec2.SecurityGroup(this, "ContainerSecurityGroup", {
      vpc: defaultVpc,
      description: "Security group for ECS containers",
      securityGroupName: `${props.stackName!}-ecs-sg`
    })

    containerSecurityGroup.addIngressRule(
      loadBalancerSecurityGroup,
      ec2.Port.tcp(props.containerPort),
      "alb to ecs"
    )
    const trustStoreBucket = Bucket.fromBucketName(this, "trustStoreBucket", props.truststoreBucketName)
    const trustStore = new TrustStore(this, "Store", {
      bucket: trustStoreBucket,
      key: props.truststoreFile
    })

    const loadBalancedFargateService = new ApplicationLoadBalancedFargateService(this, "Service", {
      assignPublicIp: true,
      certificate: albCertificate,
      cluster: ecsCluster,
      cpu: 2048,
      desiredCount: 2,
      domainName: `${props.stackName}.${epsDomainName}`,
      enableECSManagedTags: true,
      ipAddressType: IpAddressType.DUAL_STACK,
      listenerPort: 443,
      loadBalancer: FOO,
      vpc: defaultVpc,
      taskSubnets: {
        
      },
      memoryLimitMiB: 4096,
      taskImageOptions: {
        image: ecs.ContainerImage.fromRegistry("amazon/amazon-ecs-sample")
      },
      minHealthyPercent: 100
    })

    const targetGroup = new elasticloadbalancingv2.CfnTargetGroup(this, "TargetGroup", {
      healthCheckIntervalSeconds: 10,
      healthCheckPath: "/_healthcheck",
      healthCheckTimeoutSeconds: 5,
      unhealthyThresholdCount: 2,
      healthyThresholdCount: 2,
      port: 80,
      protocol: "HTTP",
      targetGroupAttributes: [
        {
          key: "deregistration_delay.timeout_seconds",
          value: 60
        }
      ],
      targetType: "ip",
      vpcId: cdk.Fn.importValue("vpc-resources:VpcId")
    })

    const ecsTaskDefinition = new ecs.CfnTaskDefinition(this, "ECSTaskDefinition", {
      family: `${props.stackName!}-task`,
      cpu: "2048",
      memory: "4096",
      networkMode: "awsvpc",
      requiresCompatibilities: [
        "FARGATE"
      ],
      executionRoleArn: ecsTaskExecutionRole.attrArn,
      containerDefinitions: [
        {
          name: `${props.stackName!}-coordinator`,
          image: `${this.account}.dkr.ecr.${this.region}.amazonaws.com/fhir-facade-repo:${props.dockerImageTag!}`,
          portMappings: [
            {
              containerPort: props.containerPort!,
              protocol: "tcp"
            }
          ],
          environment: [
            {
              name: "VALIDATOR_HOST",
              value: `${props.stackName!}-validator`
            },
            {
              name: "TARGET_SPINE_SERVER",
              value: props.targetSpineServer!
            },
            {
              name: "MTLS_SPINE_CLIENT",
              value: true
            },
            {
              name: "PRESCRIBE_ENABLED",
              value: true
            },
            {
              name: "DISPENSE_ENABLED",
              value: true
            },
            {
              name: "COMMIT_ID",
              value: props.commitId!
            },
            {
              name: "CRL_DISTRIBUTION_DOMAIN",
              value: "crl.nhs.uk"
            },
            {
              name: "CRL_DISTRIBUTION_PROXY",
              value: "crl.nhs.uk"
            },
            {
              name: "DEPLOYED_VERSION",
              value: props.versionNumber!
            },
            {
              name: "DOSE_TO_TEXT_MODE",
              value: "AUDIT"
            },
            {
              name: "ENVIRONMENT",
              value: "internal-dev"
            },
            {
              name: "LOG_LEVEL",
              value: props.logLevel!
            },
            {
              name: "NODE_ENV",
              value: "production"
            },
            {
              name: "SANDBOX",
              value: 0
            },
            {
              name: "TO_ASID",
              value: props.toAsid!
            },
            {
              name: "TO_PARTY_KEY",
              value: props.toPartyKey!
            },
            {
              name: "USE_SHA256_PREPARE",
              value: false
            }
          ],
          secrets: [
            {
              name: "SpinePrivateKey",
              valueFrom: cdk.Fn.importValue("account-resources:SpinePrivateKey")
            },
            {
              name: "SpinePublicCertificate",
              valueFrom: cdk.Fn.importValue("account-resources:SpinePublicCertificate")
            },
            {
              name: "SpineCAChain",
              valueFrom: cdk.Fn.importValue("account-resources:SpineCAChain")
            },
            {
              name: "SUBCACC_CERT",
              valueFrom: cdk.Fn.importValue("secrets:epsSigningCertChain")
            }
          ],
          logConfiguration: {
            logDriver: "awslogs",
            options: {
              "awslogs-group": coordinatorLogGroup.ref,
              "awslogs-region": this.region,
              "awslogs-stream-prefix": "ecs"
            }
          }
        },
        {
          name: `${props.stackName!}-validator`,
          image: `${this.account}.dkr.ecr.${this.region}.amazonaws.com/validator-repo:${props.dockerImageTag!}`,
          portMappings: [
            {
              containerPort: props.containerPortValidator!,
              protocol: "tcp"
            }
          ],
          environment: [
            {
              name: "LOG_LEVEL",
              value: props.validatorLogLevel!
            }
          ],
          logConfiguration: {
            logDriver: "awslogs",
            options: {
              "awslogs-group": validatorLogGroup.ref,
              "awslogs-region": this.region,
              "awslogs-stream-prefix": "ecs"
            }
          }
        }
      ],
      runtimePlatform: {
        cpuArchitecture: "X86_64",
        operatingSystemFamily: "LINUX"
      }
    })

    const loadBalancer = new elasticloadbalancingv2.CfnLoadBalancer(this, "LoadBalancer", {
      loadBalancerAttributes: [
        {
          key: "idle_timeout.timeout_seconds",
          value: 60
        },
        {
          key: "access_logs.s3.enabled",
          value: true
        },
        {
          key: "access_logs.s3.bucket",
          value: cdk.Fn.importValue("account-resources:ALBLoggingBucketName")
        },
        {
          key: "access_logs.s3.prefix",
          value: `${props.stackName!}/access`
        },
        {
          key: "connection_logs.s3.enabled",
          value: true
        },
        {
          key: "connection_logs.s3.bucket",
          value: cdk.Fn.importValue("account-resources:ALBLoggingBucketName")
        },
        {
          key: "connection_logs.s3.prefix",
          value: `${props.stackName!}/connection`
        }
      ],
      scheme: "internet-facing",
      securityGroups: [
        loadBalancerSecurityGroup.ref
      ],
      subnets: cdk.Fn.split(",", cdk.Fn.importValue("vpc-resources:PublicSubnets"))
    })

    const dnsRecord = new route53.CfnRecordSet(this, "DNSRecord", {
      hostedZoneId: cdk.Fn.importValue("eps-route53-resources:EPS-ZoneID"),
      name: [
        props.stackName!,
        cdk.Fn.importValue("eps-route53-resources:EPS-domain")
      ].join("."),
      type: "A",
      aliasTarget: {
        dnsName: loadBalancer.attrDnsName,
        evaluateTargetHealth: false,
        hostedZoneId: loadBalancer.attrCanonicalHostedZoneId
      }
    })

    const listenerHttps = new elasticloadbalancingv2.CfnListener(this, "ListenerHTTPS", {
      defaultActions: [
        {
          type: "forward",
          targetGroupArn: targetGroup.ref
        }
      ],
      loadBalancerArn: loadBalancer.ref,
      port: 443,
      protocol: "HTTPS",
      certificates: [
        {
          certificateArn: generateCertificate.ref
        }
      ],
      sslPolicy: "ELBSecurityPolicy-TLS13-1-2-2021-06",
      mutualAuthentication: createTruststore ? {
        mode: "verify",
        trustStoreArn: truststore?.attrTrustStoreArn
      } : undefined
    })

    const ecsService = new ecs.CfnService(this, "ECSService", {
      cluster: ecsCluster.ref,
      serviceName: `${props.stackName!}-service`,
      desiredCount: isRefOrProd ? 2 : 1,
      healthCheckGracePeriodSeconds: 300,
      launchType: "FARGATE",
      networkConfiguration: {
        awsvpcConfiguration: {
          assignPublicIp: "DISABLED",
          securityGroups: [
            containerSecurityGroup.ref
          ],
          subnets: cdk.Fn.split(",", cdk.Fn.importValue("vpc-resources:PrivateSubnets"))
        }
      },
      taskDefinition: ecsTaskDefinition.ref,
      loadBalancers: [
        {
          containerName: `${props.stackName!}-coordinator`,
          containerPort: props.containerPort!,
          targetGroupArn: targetGroup.ref
        }
      ]
    })
    ecsService.addDependency(listenerHttps)

    const ecsServiceAutoScalingTarget = isRefOrProd
      ? new applicationautoscaling.CfnScalableTarget(this, "ECSServiceAutoScalingTarget", {
        minCapacity: 2,
        maxCapacity: 10,
        resourceId: `service/${ecsCluster.ref}/${props.stackName!}-service`,
        roleArn: ecsServiceAutoScalingRole?.attrArn,
        scalableDimension: "ecs:service:DesiredCount",
        serviceNamespace: "ecs"
      })
      : undefined
    if (ecsServiceAutoScalingTarget != null) {
      ecsServiceAutoScalingTarget.addDependency(ecsService)
    }

    const ecsServiceAutoScalingPolicy = isRefOrProd
      ? new applicationautoscaling.CfnScalingPolicy(this, "ECSServiceAutoScalingPolicy", {
        policyName: `${props.stackName!}-ecsAutoScalingPolicy`,
        policyType: "TargetTrackingScaling",
        scalingTargetId: ecsServiceAutoScalingTarget?.ref,
        targetTrackingScalingPolicyConfiguration: {
          predefinedMetricSpecification: {
            predefinedMetricType: "ECSServiceAverageCPUUtilization"
          },
          scaleInCooldown: 300,
          scaleOutCooldown: 60,
          targetValue: 70
        }
      })
      : undefined
    if (ecsServiceAutoScalingPolicy != null) {
    }

    // Outputs
  }
}
